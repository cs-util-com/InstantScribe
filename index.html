<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Audio Recorder</title>
  <style>
    button {
      padding: 10px 15px;
      margin: 5px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #0056b3;
    }
    select {
      padding: 5px;
      margin: 5px;
    }
    #transcription-container {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 90%;
      max-width: 1200px;
      white-space: pre-wrap;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <button id="stop">Save Recording</button>
  <label for="language-select">Transcription language:</label>
  <select id="language-select">
    <option value="en-US">English (US)</option>
    <option value="en-GB">English (UK)</option>
    <option value="de-DE">German</option>
    <option value="fr-FR">French</option>
    <option value="es-ES">Spanish</option>
    <option value="it-IT">Italian</option>
    <option value="ja-JP">Japanese</option>
    <option value="zh-CN">Chinese (Simplified)</option>
  </select>
  <h3>Transcription:</h3>
  <div id="transcription-container">
    <!-- Made the transcription element contenteditable -->
    <div id="transcription" contenteditable="true"></div>
  </div>

  <script>
    // Check if the browser supports the required APIs
    if (
      !window.MediaRecorder ||
      !("webkitSpeechRecognition" in window || "SpeechRecognition" in window)
    ) {
      alert("Your browser does not support the required APIs for audio recording and transcription.");
    } else {
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          // Use a single timestamp for the entire recording session.
          const recordingStartTime = Date.now();

          // Grab DOM elements early for use in event handlers.
          const transcriptionElement = document.getElementById('transcription');
          const languageSelect = document.getElementById('language-select');
          const stopButton = document.getElementById('stop');

          // Determine a supported audio MIME type
          const mimeTypes = ['audio/mp3', 'audio/mpeg', 'audio/ogg', 'audio/mp4', 'audio/webm'];
          const mimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type)) || null;

          if (!mimeType) {
            alert("Your browser does not support MP3, OGG, MP4, or WebM audio recording.");
            return;
          }

          // Map MIME types to file extensions.
          const mimeTypeToExtension = {
            'audio/mpeg': 'mp3',
            'audio/mp3': 'mp3',
            'audio/ogg': 'ogg',
            'audio/mp4': 'mp4',
            'audio/webm': 'webm'
          };
          const fileExtension = mimeTypeToExtension[mimeType] || 'webm';

          // Set up MediaRecorder for audio recording.
          const mediaRecorder = new MediaRecorder(stream, {
            mimeType,
            audioBitsPerSecond: 32000, // 32kbps is suitable for speech.
          });
          const audioChunks = [];
          mediaRecorder.ondataavailable = event => {
            if (event.data.size > 0) {
              audioChunks.push(event.data);
            }
          };

          mediaRecorder.onstop = () => {
            const audioBlob = new Blob(audioChunks, { type: mimeType });
            const blobUrl = URL.createObjectURL(audioBlob);
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = `${getDateTimePrefix(recordingStartTime)} audio recording.${fileExtension}`;
            a.click();
            URL.revokeObjectURL(blobUrl);
          };

          // Start recording audio immediately.
          mediaRecorder.start();

          // Set up Speech Recognition for live transcription.
          const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
          let recognition = new SpeechRecognition();
          recognition.continuous = true;
          recognition.interimResults = true;
          recognition.lang = navigator.language || 'en-US';
          languageSelect.value = recognition.lang;

          let isRecording = true;
          let interimStartTime = null; // Tracks when an interim transcript begins.
          const interimSpanId = 'interim-transcript';

          recognition.onresult = (event) => {
            let finalTranscript = '';
            let interimTranscript = '';

            for (let i = event.resultIndex; i < event.results.length; ++i) {
              const result = event.results[i][0].transcript;
              if (event.results[i].isFinal) {
                finalTranscript += result;
              } else {
                interimTranscript += result;
              }
            }

            // If an interim result begins, note its start time.
            if (interimTranscript && !interimStartTime) {
              interimStartTime = Date.now();
            }

            // When a final result is available, insert it along with a timestamp.
            if (finalTranscript) {
              const existingInterimSpan = document.getElementById(interimSpanId);
              if (existingInterimSpan) {
                existingInterimSpan.remove();
              }
              if (interimStartTime) {
                const elapsed = interimStartTime - recordingStartTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                const timestampDiv = document.createElement('div');
                timestampDiv.style.fontWeight = 'bold';
                timestampDiv.style.color = 'lightgray';
                timestampDiv.textContent = `[[${padZero(minutes)}:${padZero(seconds)}]] `;
                transcriptionElement.appendChild(timestampDiv);
                interimStartTime = null;
              }
              transcriptionElement.appendChild(document.createTextNode(finalTranscript));
            }

            // Always update or add the interim transcript.
            if (interimTranscript) {
              const existingInterimSpan = document.getElementById(interimSpanId);
              if (existingInterimSpan) {
                existingInterimSpan.remove();
              }
              const interimSpan = document.createElement('span');
              interimSpan.id = interimSpanId;
              interimSpan.style.opacity = '0.5';
              interimSpan.textContent = interimTranscript;
              transcriptionElement.appendChild(interimSpan);
            }
          };

          recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            // Attempt to restart if still recording.
            if (isRecording) {
              recognition.stop();
              recognition.start();
            }
          };

          recognition.onend = () => {
            if (isRecording) {
              recognition.start();
            }
          };

          recognition.start();

          // Update language if the user selects a new option.
          languageSelect.addEventListener('change', () => {
            recognition.stop();
            recognition.lang = languageSelect.value;
            if (isRecording) {
              recognition.start();
            }
          });

          // When the user clicks the stop button, stop both audio and transcription.
          stopButton.addEventListener('click', () => {
            mediaRecorder.stop();
            recognition.stop();
            stopButton.style.display = 'none';
            isRecording = false;

            // Remove any lingering interim transcript.
            const interimSpan = document.getElementById(interimSpanId);
            if (interimSpan) {
              interimSpan.remove();
            }

            // Retrieve the (possibly edited) transcription.
            const transcriptionHTML = transcriptionElement.innerHTML;
            const transcriptionText = htmlToPlainText(transcriptionHTML);

            // Create and trigger the download of the transcription.
            const textBlob = new Blob([transcriptionText], { type: 'text/plain;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(textBlob);
            a.download = `${getDateTimePrefix(recordingStartTime)} audio transcript.txt`;
            a.click();
            URL.revokeObjectURL(a.href);
          });

          // Warn the user if they try to leave while a recording is in progress.
          window.addEventListener('beforeunload', (event) => {
            if (isRecording) {
              event.preventDefault();
              event.returnValue = 'A recording is still in progress. Are you sure you want to leave?';
            }
          });
        })
        .catch(error => {
          console.error('Error accessing microphone:', error);
          alert("Microphone access denied or unavailable.");
        });
    }

    // Utility: Generate a date/time prefix for file names.
    function getDateTimePrefix(time) {
      const date = new Date(time);
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      const seconds = String(date.getSeconds()).padStart(2, '0');
      return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
    }

    // Utility: Convert HTML content to plain text while preserving line breaks.
    function htmlToPlainText(html) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;

      function traverse(node) {
        let text = '';
        node.childNodes.forEach(child => {
          if (child.nodeType === Node.TEXT_NODE) {
            text += child.textContent;
          } else if (child.nodeType === Node.ELEMENT_NODE) {
            if (['BR', 'DIV', 'P'].includes(child.tagName)) {
              text += '\n';
            }
            text += traverse(child);
          }
        });
        return text;
      }

      return traverse(tempDiv).replace(/\n\s*\n/g, '\n\n').trim();
    }

    // Utility: Pad single-digit numbers with a leading zero.
    function padZero(num) {
      return num < 10 ? '0' + num : num;
    }
  </script>
</body>
</html>